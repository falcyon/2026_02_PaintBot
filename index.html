<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PaintBot</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a2e;
    color: #e0e0e0;
    font-family: 'Segoe UI', system-ui, sans-serif;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }

  #sidebar {
    width: 280px;
    min-width: 280px;
    background: #16213e;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-y: auto;
    border-right: 1px solid #0f3460;
  }

  #sidebar h1 {
    font-size: 1.4em;
    color: #e94560;
    margin-bottom: 4px;
  }

  #sidebar h2 {
    font-size: 0.85em;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #0f3460;
    border-bottom: 1px solid #0f3460;
    padding-bottom: 4px;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .control-row label {
    font-size: 0.82em;
    white-space: nowrap;
  }

  .control-row input[type="range"] {
    flex: 1;
    max-width: 120px;
    accent-color: #e94560;
  }

  .control-row .val {
    font-size: 0.75em;
    min-width: 32px;
    text-align: right;
    color: #aaa;
  }

  select, button {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a3a6e;
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 0.85em;
    cursor: pointer;
  }

  button:hover { background: #e94560; }

  button.danger { background: #6e1020; border-color: #9e2040; }
  button.danger:hover { background: #c0304a; }

  #bot-list {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .bot-entry {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    border-radius: 4px;
    background: #1a1a2e;
    font-size: 0.78em;
  }

  .bot-swatch {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .bot-ink-bar {
    flex: 1;
    height: 6px;
    background: #0a0a15;
    border-radius: 3px;
    overflow: hidden;
  }

  .bot-ink-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.3s;
  }

  .bot-status {
    font-size: 0.7em;
    color: #888;
    min-width: 40px;
    text-align: right;
  }

  #canvas-wrap {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;
    position: relative;
  }

  #canvas {
    background: #ffffff;
    border-radius: 6px;
    box-shadow: 0 0 30px rgba(233, 69, 96, 0.08);
  }

  #overlay {
    background: transparent;
    border-radius: 6px;
  }

  #stats {
    position: absolute;
    top: 18px;
    right: 24px;
    font-size: 0.72em;
    color: #555;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h1>PaintBot</h1>

  <h2>New Bot Settings</h2>
  <div class="control-group">
    <div class="control-row">
      <label>Speed (in/tick)</label>
      <input type="range" id="opt-speed" min="0.02" max="0.3" step="0.01" value="0.08">
      <span class="val" id="val-speed">0.08</span>
    </div>
    <div class="control-row">
      <label>Ink (in)</label>
      <input type="range" id="opt-ink" min="50" max="2000" step="50" value="500">
      <span class="val" id="val-ink">500</span>
    </div>
    <div class="control-row">
      <label>Width (in)</label>
      <input type="range" id="opt-width" min="0.02" max="0.5" step="0.01" value="0.15">
      <span class="val" id="val-width">0.15</span>
    </div>
    <div class="control-row">
      <label>Wiggle</label>
      <input type="range" id="opt-noise" min="0.01" max="0.2" step="0.01" value="0.08">
      <span class="val" id="val-noise">0.08</span>
    </div>
    <div class="control-row">
      <label>Max Turn (&deg;)</label>
      <input type="range" id="opt-turn" min="1" max="45" step="1" value="10">
      <span class="val" id="val-turn">10</span>
    </div>
  </div>
  <p style="font-size:0.65em;color:#555;margin-top:-4px;">Canvas: 66&times;37 in</p>

  <div style="display:flex;gap:6px;">
    <button id="btn-add" style="flex:1;">+ Add Bot</button>
    <button id="btn-add5">+5</button>
  </div>

  <div style="display:flex;gap:6px;">
    <button id="btn-pause" style="flex:1;">Pause</button>
    <button id="btn-clear" class="danger">Clear All</button>
  </div>

  <h2>Active Bots</h2>
  <div id="bot-list"></div>
</div>

<div id="canvas-wrap">
  <canvas id="canvas"></canvas>
  <canvas id="overlay" style="position:absolute;pointer-events:none;"></canvas>
  <div id="stats"></div>
</div>

<script>
// ─── World Constants (inches) ──────────────────────────────────────────────
const WORLD_W = 66;
const WORLD_H = 37;
const CONE_HALF_DEG = 15;
const CONE_RANGE = 1.5; // inches
const CONE_HALF = CONE_HALF_DEG * (Math.PI / 180);
let scale = 1; // pixels per inch

// ─── Simplex Noise (fast 2D) ──────────────────────────────────────────────
const SimplexNoise = (() => {
  const F2 = 0.5 * (Math.sqrt(3) - 1);
  const G2 = (3 - Math.sqrt(3)) / 6;
  const grad3 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];

  function create(seed) {
    const perm = new Uint8Array(512);
    const p = new Uint8Array(256);
    let s = seed | 0;
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      const j = s % (i + 1);
      [p[i], p[j]] = [p[j], p[i]];
    }
    for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

    return function noise2D(x, y) {
      const s = (x + y) * F2;
      const i = Math.floor(x + s);
      const j = Math.floor(y + s);
      const t = (i + j) * G2;
      const X0 = i - t, Y0 = j - t;
      const x0 = x - X0, y0 = y - Y0;
      let i1, j1;
      if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
      const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
      const ii = i & 255, jj = j & 255;
      let n0 = 0, n1 = 0, n2 = 0;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 > 0) { t0 *= t0; const g = grad3[perm[ii + perm[jj]] % 8]; n0 = t0 * t0 * (g[0] * x0 + g[1] * y0); }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 > 0) { t1 *= t1; const g = grad3[perm[ii + i1 + perm[jj + j1]] % 8]; n1 = t1 * t1 * (g[0] * x1 + g[1] * y1); }
      let t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 > 0) { t2 *= t2; const g = grad3[perm[ii + 1 + perm[jj + 1]] % 8]; n2 = t2 * t2 * (g[0] * x2 + g[1] * y2); }
      return 70 * (n0 + n1 + n2);
    };
  }
  return { create };
})();

// ─── Color Palette ─────────────────────────────────────────────────────────
function randomColor() {
  if (Math.random() < 0.5) return { str: '#d64550' };
  return { str: '#00a6a6' };
}

// ─── Bot Class (all units in inches) ───────────────────────────────────────
class Bot {
  static nextId = 0;

  constructor(opts = {}) {
    this.id = Bot.nextId++;

    this.x = opts.x ?? (1 + Math.random() * (WORLD_W - 2));
    this.y = opts.y ?? (1 + Math.random() * (WORLD_H - 2));
    this.heading = Math.random() * Math.PI * 2;

    this.speed = opts.speed ?? 0.04;       // inches per tick
    this.ink = opts.ink ?? 500;             // inches of travel
    this.maxInk = this.ink;
    this.lineWidth = opts.lineWidth ?? 0.15; // inches
    this.wiggle = opts.wiggle ?? 0.02;      // noise time step
    this.maxTurnDeg = opts.maxTurnDeg ?? 10;

    this.color = randomColor();
    this.alive = true;
    this.seed = Math.floor(Math.random() * 999999);
    this.noise = SimplexNoise.create(this.seed);
    this.t = Math.random() * 10000;

    this.prevX = this.x;
    this.prevY = this.y;
  }

  update() {
    if (!this.alive) return;

    this.prevX = this.x;
    this.prevY = this.y;

    // smooth noise turn
    this.t += this.wiggle;
    const n = this.noise(this.t, this.seed);
    let turn = n * this.maxTurnDeg * (Math.PI / 180);

    // visibility cone edge avoidance
    turn += this._avoidEdges();

    this.heading += turn;

    // step forward at constant speed
    this.x += Math.cos(this.heading) * this.speed;
    this.y += Math.sin(this.heading) * this.speed;

    // safety clamp (should rarely trigger)
    this.x = Math.max(0, Math.min(WORLD_W, this.x));
    this.y = Math.max(0, Math.min(WORLD_H, this.y));

    this.ink -= this.speed;
    if (this.ink <= 0) { this.ink = 0; this.alive = false; }
  }

  _rayToEdge(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    let d = Infinity;
    if (c > 0.0001)  d = Math.min(d, (WORLD_W - this.x) / c);
    if (c < -0.0001) d = Math.min(d, -this.x / c);
    if (s > 0.0001)  d = Math.min(d, (WORLD_H - this.y) / s);
    if (s < -0.0001) d = Math.min(d, -this.y / s);
    return Math.max(0, d);
  }

  _avoidEdges() {
    // repulsion from all nearby walls (handles corners naturally)
    const dL = this.x, dR = WORLD_W - this.x;
    const dT = this.y, dB = WORLD_H - this.y;

    let repX = 0, repY = 0;
    if (dL < CONE_RANGE) repX += 1 - dL / CONE_RANGE;
    if (dR < CONE_RANGE) repX -= 1 - dR / CONE_RANGE;
    if (dT < CONE_RANGE) repY += 1 - dT / CONE_RANGE;
    if (dB < CONE_RANGE) repY -= 1 - dB / CONE_RANGE;

    if (repX === 0 && repY === 0) return 0;

    // desired heading away from walls
    const awayAngle = Math.atan2(repY, repX);
    let diff = awayAngle - this.heading;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;

    const urgency = Math.min(1, Math.sqrt(repX * repX + repY * repY));
    const maxSteer = this.maxTurnDeg * (Math.PI / 180);
    return Math.max(-maxSteer * 3, Math.min(maxSteer * 3, diff * urgency * 2));
  }

  drawTrail(ctx) {
    ctx.globalAlpha = Math.max(0.15, this.ink / this.maxInk);
    ctx.strokeStyle = this.color.str;
    ctx.lineWidth = this.lineWidth * scale;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(this.prevX * scale, this.prevY * scale);
    ctx.lineTo(this.x * scale, this.y * scale);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  drawSprite(ctx) {
    if (!this.alive) return;
    const sz = (this.lineWidth + 0.6) * scale; // sprite size in px
    const h = this.heading;
    const px = this.x * scale, py = this.y * scale;

    const noseX = px + Math.cos(h) * sz;
    const noseY = py + Math.sin(h) * sz;
    const rearLX = px + Math.cos(h + Math.PI + 0.45) * sz * 0.7;
    const rearLY = py + Math.sin(h + Math.PI + 0.45) * sz * 0.7;
    const rearRX = px + Math.cos(h + Math.PI - 0.45) * sz * 0.7;
    const rearRY = py + Math.sin(h + Math.PI - 0.45) * sz * 0.7;

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.moveTo(noseX, noseY);
    ctx.lineTo(rearLX, rearLY);
    ctx.lineTo(rearRX, rearRY);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(noseX, noseY, Math.max(1, scale * 0.08), 0, Math.PI * 2);
    ctx.fill();

    // visibility cone from nose tip
    const coneR = CONE_RANGE * scale;
    ctx.fillStyle = 'rgba(255, 220, 0, 0.12)';
    ctx.strokeStyle = 'rgba(255, 200, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(noseX, noseY);
    ctx.arc(noseX, noseY, coneR, h - CONE_HALF, h + CONE_HALF);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

// ─── App ───────────────────────────────────────────────────────────────────
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const oCtx = overlay.getContext('2d');
const botListEl = document.getElementById('bot-list');
const statsEl = document.getElementById('stats');

let bots = [];
let paused = false;
let frame = 0;

function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  const availW = wrap.clientWidth - 24;
  const availH = wrap.clientHeight - 24;
  scale = Math.min(availW / WORLD_W, availH / WORLD_H);
  const pw = Math.floor(WORLD_W * scale);
  const ph = Math.floor(WORLD_H * scale);

  canvas.width = pw;
  canvas.height = ph;
  overlay.width = pw;
  overlay.height = ph;

  // position overlay on top of canvas after layout
  requestAnimationFrame(() => {
    overlay.style.left = canvas.offsetLeft + 'px';
    overlay.style.top = canvas.offsetTop + 'px';
  });

  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, pw, ph);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function readOpts() {
  return {
    speed: parseFloat(document.getElementById('opt-speed').value),
    ink: parseFloat(document.getElementById('opt-ink').value),
    lineWidth: parseFloat(document.getElementById('opt-width').value),
    wiggle: parseFloat(document.getElementById('opt-noise').value),
    maxTurnDeg: parseInt(document.getElementById('opt-turn').value),
  };
}

function spawnBot(opts) {
  const merged = { ...readOpts(), ...opts };
  bots.push(new Bot(merged));
}

// slider value display
document.querySelectorAll('#sidebar input[type="range"]').forEach(el => {
  const valSpan = document.getElementById('val-' + el.id.replace('opt-', ''));
  el.addEventListener('input', () => { valSpan.textContent = el.value; });
});

// buttons
document.getElementById('btn-add').addEventListener('click', () => spawnBot());
document.getElementById('btn-add5').addEventListener('click', () => {
  for (let i = 0; i < 5; i++) spawnBot();
});

document.getElementById('btn-pause').addEventListener('click', () => {
  paused = !paused;
  document.getElementById('btn-pause').textContent = paused ? 'Resume' : 'Pause';
});

document.getElementById('btn-clear').addEventListener('click', () => {
  bots = [];
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
});

// ─── Render Loop ───────────────────────────────────────────────────────────
function tick() {
  requestAnimationFrame(tick);
  if (paused) return;
  frame++;

  oCtx.clearRect(0, 0, overlay.width, overlay.height);
  for (const bot of bots) {
    bot.update();
    bot.drawTrail(ctx);
    bot.drawSprite(oCtx);
  }

  if (frame % 15 === 0) updateBotList();
}

function updateBotList() {
  const alive = bots.filter(b => b.alive).length;
  statsEl.textContent = `${alive} active / ${bots.length} total`;

  botListEl.innerHTML = '';
  for (const bot of bots) {
    const pct = Math.max(0, (bot.ink / bot.maxInk) * 100);
    const entry = document.createElement('div');
    entry.className = 'bot-entry';
    entry.innerHTML = `
      <div class="bot-swatch" style="background:${bot.color.str};opacity:${bot.alive ? 1 : 0.3}"></div>
      <span style="min-width:18px;font-size:0.7em;">#${bot.id}</span>
      <div class="bot-ink-bar">
        <div class="bot-ink-fill" style="width:${pct}%;background:${bot.color.str};opacity:${bot.alive ? 0.9 : 0.3}"></div>
      </div>
      <span class="bot-status">${bot.alive ? Math.round(pct) + '%' : 'done'}</span>
    `;
    botListEl.appendChild(entry);
  }
}

for (let i = 0; i < 5; i++) spawnBot();
tick();
</script>
</body>
</html>
